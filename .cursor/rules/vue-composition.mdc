---
description: Vue 3 Composition API 编码规范
globs: ['**/*.vue']
alwaysApply: true
---

# Vue 3 Composition API 编码规范

此文件为 Cursor 编辑器提供 Vue 3 Composition API 的编码规范，确保组件开发的一致性和最佳实践。

## 组件结构规范

### 标准组件结构

```vue
<template lang="pug">
// 模板内容
</template>

<script setup lang="ts">
// 导入语句
// 类型定义
// Props 定义
// Emits 定义
// 响应式数据
// 计算属性
// 方法
// 生命周期钩子
// 暴露给父组件的方法
</script>

<style lang="scss" scoped>
// 样式定义
</style>
```

### 导入顺序规范

```typescript
// 1. Vue 核心 API
import { ref, reactive, computed, watch, onMounted, onUnmounted } from 'vue'

// 2. Vue 路由和状态管理
import { useRouter, useRoute } from 'vue-router'
import { useUserStore } from '@/stores'

// 3. 第三方库
import { Button } from 'primevue/button'
import { debounce } from 'lodash-es'

// 4. 项目内部模块
import { formatDate } from '@/utils'
import { getUserApi } from '@!/index'
import { deepClone } from '@#/index'

// 5. 类型定义
import type { UserInfo, ApiResponse } from '@/types'

// 6. 本地组件
import UserCard from './components/UserCard.vue'
```

## Props 定义规范

### 基础 Props 定义

```typescript
// ✅ 正确：完整的 Props 类型定义
interface UserListProps {
  users: UserInfo[]
  loading?: boolean
  showActions?: boolean
  onUserSelect?: (user: UserInfo) => void
  onUserEdit?: (user: UserInfo) => void
  onUserDelete?: (userId: string) => void
}

const props = withDefaults(defineProps<UserListProps>(), {
  loading: false,
  showActions: true,
  onUserSelect: undefined,
  onUserEdit: undefined,
  onUserDelete: undefined,
})

// ❌ 错误：缺少类型定义
const props = defineProps({
  users: Array,
  loading: Boolean,
})
```

### 复杂 Props 验证

```typescript
// ✅ 正确：带验证的 Props
interface FormProps {
  initialData?: Partial<UserInfo>
  validationRules?: ValidationRule[]
  submitText?: string
}

const props = withDefaults(defineProps<FormProps>(), {
  initialData: () => ({}),
  validationRules: () => [],
  submitText: '提交',
})

// Props 验证
const isValidProps = computed(() => {
  return props.users.length > 0 && Array.isArray(props.users)
})
```

## Emits 定义规范

### Emits 类型定义

```typescript
// ✅ 正确：明确的 Emits 类型
interface UserListEmits {
  userSelect: [user: UserInfo]
  userEdit: [user: UserInfo]
  userDelete: [userId: string]
  loadingChange: [loading: boolean]
}

const emit = defineEmits<UserListEmits>()

// ✅ 正确：带验证的 Emits
const emit = defineEmits<UserListEmits>({
  userSelect: (user: UserInfo) => user && typeof user.id === 'string',
  userEdit: (user: UserInfo) => user && typeof user.id === 'string',
  userDelete: (userId: string) => typeof userId === 'string',
  loadingChange: (loading: boolean) => typeof loading === 'boolean',
})
```

### Emits 使用规范

```typescript
// ✅ 正确：类型安全的 emit 调用
const handleUserClick = (user: UserInfo) => {
  emit('userSelect', user)
}

const handleEdit = (user: UserInfo) => {
  emit('userEdit', user)
}

const handleDelete = (userId: string) => {
  emit('userDelete', userId)
}

// ❌ 错误：缺少类型检查
const handleUserClick = (user: any) => {
  emit('userSelect', user)
}
```

## 响应式数据规范

### ref 使用规范

```typescript
// ✅ 正确：基础类型使用 ref
const loading = ref<boolean>(false)
const userName = ref<string>('')
const userCount = ref<number>(0)
const selectedUser = ref<UserInfo | null>(null)

// ✅ 正确：数组和对象使用 ref
const userList = ref<UserInfo[]>([])
const formData = ref<Partial<UserInfo>>({})
const errorMessage = ref<string | null>(null)

// ❌ 错误：不必要的 ref 包装
const simpleFlag = ref(true) // 如果不需要响应式，使用普通变量
```

### reactive 使用规范

```typescript
// ✅ 正确：复杂对象使用 reactive
const formState = reactive<{
  data: Partial<UserInfo>
  errors: Record<string, string>
  touched: Record<string, boolean>
}>({
  data: {},
  errors: {},
  touched: {},
})

// ✅ 正确：配置对象使用 reactive
const config = reactive<{
  theme: 'light' | 'dark'
  language: string
  autoSave: boolean
}>({
  theme: 'light',
  language: 'zh-CN',
  autoSave: true,
})

// ❌ 错误：基础类型使用 reactive
const count = reactive(0) // 应该使用 ref(0)
```

### 响应式数据解构

```typescript
// ✅ 正确：使用 toRefs 解构
const userStore = useUserStore()
const { user, loading, error } = toRefs(userStore)

// ✅ 正确：选择性解构
const { user } = toRefs(userStore)
const loading = computed(() => userStore.loading)

// ❌ 错误：直接解构响应式对象
const { user, loading } = userStore // 失去响应性
```

## 计算属性规范

### 基础计算属性

```typescript
// ✅ 正确：简单的计算属性
const displayName = computed(() => {
  return user.value ? `${user.value.firstName} ${user.value.lastName}` : '未知用户'
})

const isFormValid = computed(() => {
  return formData.value.name && formData.value.email
})

// ✅ 正确：带依赖的计算属性
const filteredUsers = computed(() => {
  return userList.value.filter(user =>
    user.name.toLowerCase().includes(searchQuery.value.toLowerCase())
  )
})
```

### 复杂计算属性

```typescript
// ✅ 正确：复杂的计算属性
const userStatistics = computed(() => {
  const users = userList.value
  return {
    total: users.length,
    active: users.filter(u => u.status === 'active').length,
    inactive: users.filter(u => u.status === 'inactive').length,
    averageAge: users.reduce((sum, u) => sum + u.age, 0) / users.length,
  }
})

// ✅ 正确：条件计算属性
const canEdit = computed(() => {
  return user.value && user.value.permissions.includes('edit') && !loading.value
})
```

## 监听器规范

### watch 使用规范

```typescript
// ✅ 正确：监听单个响应式引用
watch(
  user,
  (newUser, oldUser) => {
    if (newUser && newUser.id !== oldUser?.id) {
      fetchUserDetails(newUser.id)
    }
  },
  { immediate: true }
)

// ✅ 正确：监听多个响应式引用
watch([user, loading], ([newUser, newLoading], [oldUser, oldLoading]) => {
  if (newUser && !newLoading && oldLoading) {
    console.log('用户数据加载完成')
  }
})

// ✅ 正确：深度监听对象
watch(
  formData,
  newData => {
    validateForm(newData)
  },
  { deep: true }
)
```

### watchEffect 使用规范

```typescript
// ✅ 正确：自动依赖收集
watchEffect(() => {
  if (user.value && user.value.id) {
    fetchUserPermissions(user.value.id)
  }
})

// ✅ 正确：清理副作用
watchEffect(onInvalidate => {
  const timer = setInterval(() => {
    updateTimestamp()
  }, 1000)

  onInvalidate(() => {
    clearInterval(timer)
  })
})
```

## 生命周期钩子规范

### 生命周期使用顺序

```typescript
// ✅ 正确：生命周期钩子顺序
onMounted(() => {
  // 组件挂载后的初始化
  initializeComponent()
})

onUpdated(() => {
  // 组件更新后的处理
  handleComponentUpdate()
})

onUnmounted(() => {
  // 组件卸载前的清理
  cleanup()
})

// ✅ 正确：异步初始化
onMounted(async () => {
  try {
    loading.value = true
    await fetchInitialData()
  } catch (error) {
    console.error('初始化失败:', error)
  } finally {
    loading.value = false
  }
})
```

## 方法定义规范

### 事件处理方法

```typescript
// ✅ 正确：事件处理方法命名
const handleUserClick = (user: UserInfo) => {
  selectedUser.value = user
  emit('userSelect', user)
}

const handleFormSubmit = async (event: Event) => {
  event.preventDefault()

  try {
    loading.value = true
    await submitForm(formData.value)
    emit('success')
  } catch (error) {
    console.error('提交失败:', error)
    emit('error', error)
  } finally {
    loading.value = false
  }
}

// ✅ 正确：防抖和节流
const debouncedSearch = debounce((query: string) => {
  searchUsers(query)
}, 300)

const throttledScroll = throttle((event: Event) => {
  handleScroll(event)
}, 100)
```

### 业务逻辑方法

```typescript
// ✅ 正确：业务逻辑方法
const fetchUserData = async (userId: string) => {
  try {
    loading.value = true
    error.value = null

    const response = await getUserApi(userId)
    user.value = response.data
  } catch (err) {
    error.value = err instanceof Error ? err.message : '获取用户失败'
    throw err
  } finally {
    loading.value = false
  }
}

const updateUserData = async (data: Partial<UserInfo>) => {
  if (!user.value) return

  try {
    loading.value = true
    const response = await updateUserApi(user.value.id, data)
    user.value = { ...user.value, ...response.data }
  } catch (err) {
    error.value = err instanceof Error ? err.message : '更新用户失败'
    throw err
  } finally {
    loading.value = false
  }
}
```

## 组件暴露规范

### defineExpose 使用

```typescript
// ✅ 正确：暴露必要的方法和属性
const resetForm = () => {
  formData.value = {}
  errors.value = {}
}

const validateForm = () => {
  // 验证逻辑
  return isFormValid.value
}

const submitForm = async () => {
  // 提交逻辑
}

// 暴露给父组件
defineExpose({
  resetForm,
  validateForm,
  submitForm,
  isValid: isFormValid,
})

// ❌ 错误：暴露内部状态
defineExpose({
  formData, // 不应该暴露内部状态
  errors, // 不应该暴露内部状态
})
```

## 样式规范

### Scoped 样式

```scss
// ✅ 正确：使用 scoped 样式
<style lang="scss" scoped>
.user-list {
  padding: 1rem;

  &__item {
    margin-bottom: 0.5rem;
    padding: 0.75rem;
    border: 1px solid #e5e7eb;
    border-radius: 0.375rem;

    &:hover {
      background-color: #f9fafb;
    }
  }

  &__actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }
}
</style>
```

### CSS 变量使用

```scss
// ✅ 正确：使用 CSS 变量
<style lang="scss" scoped>
.user-card {
  --card-padding: 1rem;
  --card-border-radius: 0.5rem;
  --card-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);

  padding: var(--card-padding);
  border-radius: var(--card-border-radius);
  box-shadow: var(--card-shadow);
}
</style>
```

## 性能优化规范

### 响应式优化

```typescript
// ✅ 正确：使用 shallowRef 优化大对象
const largeDataList = shallowRef<LargeDataItem[]>([])

// ✅ 正确：使用 readonly 防止意外修改
const userStore = useUserStore()
const { user } = storeToRefs(userStore)
const readonlyUser = readonly(user)

// ✅ 正确：使用 markRaw 标记非响应式对象
const chartInstance = markRaw(echarts.init(chartRef.value))
```

### 计算属性优化

```typescript
// ✅ 正确：缓存计算结果
const expensiveValue = computed(() => {
  return heavyCalculation(data.value)
})

// ✅ 正确：避免在计算属性中产生副作用
const processedData = computed(() => {
  return data.value.map(item => ({
    ...item,
    processed: true,
  }))
})
```

---

**注意**: 严格遵循 Vue 3 Composition API 最佳实践，确保组件的可维护性和性能。优先使用 `<script setup>` 语法，保持代码简洁和类型安全。
