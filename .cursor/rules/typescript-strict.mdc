---
description: TypeScript 严格模式和类型安全规范
globs: ['**/*.{ts,tsx,vue}']
alwaysApply: true
---

# TypeScript 严格模式和类型安全规范

此文件为 Cursor 编辑器提供 TypeScript 严格模式的编码规范，确保类型安全和代码质量。

## 严格模式配置遵循

### 项目 TypeScript 配置

- **严格模式**: 启用所有严格检查选项
- **路径映射**: 严格使用 `@/*`, `@!/*`, `@#/*` 别名
- **模块解析**: 遵循 `tsconfig.json` 配置
- **类型检查**: 启用所有类型检查选项

## 类型声明规范

### 基础类型声明

```typescript
// ✅ 正确：明确的类型声明
const userName: string = 'admin'
const userAge: number = 25
const isActive: boolean = true
const userList: UserInfo[] = []
const userMap: Map<string, UserInfo> = new Map()

// ❌ 错误：使用 any 类型
const userName: any = 'admin'
const userData: any = {}
```

### 接口定义规范

```typescript
// ✅ 正确：完整的接口定义
interface UserInfo {
  readonly id: string
  name: string
  email: string
  avatar?: string
  status: UserStatus
  createdAt: Date
  updatedAt: Date
}

// ✅ 正确：泛型接口
interface ApiResponse<T> {
  data: T
  message: string
  success: boolean
  timestamp: number
}

// ❌ 错误：不完整的接口
interface UserInfo {
  id: any
  name: any
}
```

### 类型别名规范

```typescript
// ✅ 正确：明确的类型别名
type UserRole = 'admin' | 'user' | 'guest'
type UserStatus = 'active' | 'inactive' | 'pending'
type EventHandler<T> = (event: T) => void

// ✅ 正确：复杂类型别名
type UserWithPermissions = UserInfo & {
  permissions: Permission[]
  roles: UserRole[]
}

// ❌ 错误：模糊的类型别名
type UserData = any
type ApiData = object
```

### 枚举定义规范

```typescript
// ✅ 正确：明确的枚举值
enum UserStatus {
  Active = 'active',
  Inactive = 'inactive',
  Pending = 'pending',
}

enum HttpMethod {
  GET = 'GET',
  POST = 'POST',
  PUT = 'PUT',
  DELETE = 'DELETE',
}

// ❌ 错误：数字枚举（除非必要）
enum UserStatus {
  Active,
  Inactive,
  Pending,
}
```

## 函数类型规范

### 函数签名规范

```typescript
// ✅ 正确：完整的函数类型
const fetchUser = async (userId: string): Promise<UserInfo> => {
  // 实现
}

const handleUserClick = (user: UserInfo, event: MouseEvent): void => {
  // 实现
}

// ✅ 正确：重载函数
function processUserData(data: string): UserInfo
function processUserData(data: UserInfo): UserInfo
function processUserData(data: string | UserInfo): UserInfo {
  // 实现
}

// ❌ 错误：缺少类型注解
const fetchUser = async userId => {
  // 实现
}
```

### 回调函数类型

```typescript
// ✅ 正确：明确的回调类型
type UserCallback = (user: UserInfo) => void
type ErrorCallback = (error: Error) => void

const onUserSelect: UserCallback = user => {
  console.log('Selected user:', user.name)
}

// ✅ 正确：事件处理器类型
const handleSubmit: (event: SubmitEvent) => void = event => {
  event.preventDefault()
  // 处理逻辑
}
```

## 泛型使用规范

### 泛型约束

```typescript
// ✅ 正确：泛型约束
interface Repository<T extends { id: string }> {
  findById(id: string): Promise<T | null>
  save(entity: T): Promise<T>
  delete(id: string): Promise<void>
}

// ✅ 正确：条件类型
type NonNullable<T> = T extends null | undefined ? never : T
type ApiData<T> = T extends string ? string : T extends number ? number : unknown

// ❌ 错误：无约束的泛型
interface Repository<T> {
  findById(id: any): Promise<T>
}
```

### 工具类型使用

```typescript
// ✅ 正确：使用内置工具类型
type PartialUser = Partial<UserInfo>
type RequiredUser = Required<UserInfo>
type UserEmail = Pick<UserInfo, 'email'>
type UserWithoutId = Omit<UserInfo, 'id'>

// ✅ 正确：自定义工具类型
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}
```

## 错误处理类型规范

### 错误类型定义

```typescript
// ✅ 正确：自定义错误类型
class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code?: string
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public value: unknown
  ) {
    super(message)
    this.name = 'ValidationError'
  }
}

// ✅ 正确：错误联合类型
type AppError = ApiError | ValidationError | Error
```

### 错误处理函数

```typescript
// ✅ 正确：类型安全的错误处理
const handleApiError = (error: unknown): string => {
  if (error instanceof ApiError) {
    return `API错误 (${error.statusCode}): ${error.message}`
  }

  if (error instanceof ValidationError) {
    return `验证错误 (${error.field}): ${error.message}`
  }

  if (error instanceof Error) {
    return error.message
  }

  return '未知错误'
}

// ✅ 正确：Result 类型模式
type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E }

const fetchUser = async (id: string): Promise<Result<UserInfo, ApiError>> => {
  try {
    const user = await getUserApi(id)
    return { success: true, data: user }
  } catch (error) {
    return {
      success: false,
      error: error instanceof ApiError ? error : new ApiError('获取用户失败', 500),
    }
  }
}
```

## 组件类型规范

### Vue 组件 Props 类型

```typescript
// ✅ 正确：完整的 Props 类型
interface UserCardProps {
  user: UserInfo
  showActions?: boolean
  onEdit?: (user: UserInfo) => void
  onDelete?: (userId: string) => void
}

const UserCard = defineComponent<UserCardProps>({
  props: {
    user: {
      type: Object as PropType<UserInfo>,
      required: true,
    },
    showActions: {
      type: Boolean,
      default: false,
    },
    onEdit: {
      type: Function as PropType<(user: UserInfo) => void>,
      default: undefined,
    },
    onDelete: {
      type: Function as PropType<(userId: string) => void>,
      default: undefined,
    },
  },
})

// ❌ 错误：缺少类型定义
const UserCard = defineComponent({
  props: {
    user: Object,
    showActions: Boolean,
  },
})
```

### 组件 Emits 类型

```typescript
// ✅ 正确：明确的 Emits 类型
interface UserCardEmits {
  edit: [user: UserInfo]
  delete: [userId: string]
  update: [user: UserInfo]
}

const UserCard = defineComponent<UserCardProps, UserCardEmits>({
  emits: {
    edit: (user: UserInfo) => user && typeof user.id === 'string',
    delete: (userId: string) => typeof userId === 'string',
    update: (user: UserInfo) => user && typeof user.id === 'string',
  },
})
```

## 异步操作类型规范

### Promise 类型

```typescript
// ✅ 正确：明确的 Promise 类型
const fetchUserData = async (): Promise<UserInfo[]> => {
  const response = await fetch('/api/users')
  const data: ApiResponse<UserInfo[]> = await response.json()
  return data.data
}

// ✅ 正确：错误处理的 Promise
const safeFetchUser = async (id: string): Promise<UserInfo | null> => {
  try {
    const user = await getUserApi(id)
    return user
  } catch (error) {
    console.error('获取用户失败:', error)
    return null
  }
}

// ❌ 错误：缺少返回类型
const fetchUserData = async () => {
  // 实现
}
```

### 异步迭代器类型

```typescript
// ✅ 正确：异步迭代器类型
async function* fetchUsersBatch(): AsyncGenerator<UserInfo[], void, unknown> {
  let page = 1
  const pageSize = 10

  while (true) {
    const users = await fetchUsersPage(page, pageSize)
    if (users.length === 0) break

    yield users
    page++
  }
}
```

## 模块声明规范

### 全局类型声明

```typescript
// ✅ 正确：全局类型声明
declare global {
  interface Window {
    __APP_CONFIG__: {
      apiUrl: string
      version: string
    }
  }

  namespace NodeJS {
    interface ProcessEnv {
      NODE_ENV: 'development' | 'production' | 'test'
      VITE_API_URL: string
    }
  }
}

// ✅ 正确：模块声明
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}
```

## 类型守卫规范

### 类型守卫函数

```typescript
// ✅ 正确：类型守卫函数
const isUserInfo = (value: unknown): value is UserInfo => {
  return (
    typeof value === 'object' &&
    value !== null &&
    typeof (value as UserInfo).id === 'string' &&
    typeof (value as UserInfo).name === 'string' &&
    typeof (value as UserInfo).email === 'string'
  )
}

const isApiError = (error: unknown): error is ApiError => {
  return error instanceof ApiError
}

// ✅ 正确：使用类型守卫
const processUserData = (data: unknown) => {
  if (isUserInfo(data)) {
    // data 现在是 UserInfo 类型
    console.log(data.name)
  }
}
```

## 严格模式检查

### 空值检查

```typescript
// ✅ 正确：严格的空值检查
const processUser = (user: UserInfo | null) => {
  if (user === null) {
    throw new Error('用户不能为空')
  }

  // user 现在是 UserInfo 类型
  return user.name
}

// ✅ 正确：可选链操作符
const getUserName = (user: UserInfo | null) => {
  return user?.name ?? '未知用户'
}
```

### 类型断言规范

```typescript
// ✅ 正确：类型断言（谨慎使用）
const userElement = document.getElementById('user') as HTMLDivElement

// ✅ 正确：非空断言（谨慎使用）
const user = getUser()! // 确保 getUser 不会返回 null

// ❌ 错误：过度使用类型断言
const user = data as UserInfo // 应该使用类型守卫
```

---

**注意**: 严格遵循 TypeScript 严格模式，确保类型安全和代码质量。避免使用 `any` 类型，优先使用类型守卫和类型断言。
